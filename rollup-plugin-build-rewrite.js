import path from 'path';
import fs from 'fs-extra';
import { parse } from 'parse5';
import { queryAll, predicates, getAttribute, getTextContent } from '@open-wc/building-utils/dom5-fork/index.js';
// TODO (pawel): This plugin reads generated by `webpack-index-html-plugin` index file
// and creates a JS import file. This is not scalable and inefficient. It's quick though.
// This should be a new webpack plugin, similar to `webpack-index-html-plugin` but instead of
// generating HTML it would generate JS import file.
class ElementProcessor {
  get index() {
    return path.join(__dirname, 'dist', 'index.html');
  }

  get script() {
    return path.join(__dirname, 'dist', 'apic-import.js');
  }

  async readIndexAst() {
    const content = await fs.readFile(this.index, 'utf8');
    return parse(content);
  }

  async write(content) {
    await fs.writeFile(this.script, content, 'utf8');
  }

  async processBundle() {
    const indexHTML = await this.readIndexAst();
    const scripts = queryAll(indexHTML, predicates.hasTagName('script'));
    const value = this._buildTemplate(scripts);
    await this.write(value);
  }

  _buildTemplate(scripts) {
    let result = this._noModuleScriptLoaderTemplate();
    scripts.forEach((script) => {
      const src = getAttribute(script, 'src');
      if (src) {
        result += `addScript('${src}');`;
      } else {
        let content = getTextContent(script);
        if (content.startsWith('window.importShim=s')) {
          content = this._importShim();
        }
        // it appears that variable names aren't random. This means
        // we can use direct name search instead of regexp.
        if (content.indexOf('{src:t') !== -1) {
          content = content.replace('{src:t', '{src:bp+t');
        }
        result += 'try{';
        result += content + '';
        result += '}catch(_){};';
      }
    });
    return result;
  }
  /**
   * This rewrites open-wc's import shim to use absolute paths.
   * @return {String}
   */
  _importShim() {
    let result = 'window.importShim=s=>{';
    result += 's=bp+s; return import(s);';
    result += '}';
    return result;
  }

  _noModuleScriptLoaderTemplate() {
    return `
var st=document.getElementsByTagName('script');
var au=st[st.length - 1].src;
var bp = au.replace('apic-import.js', '');
function addScript(src) {
  var s = document.createElement('script');
  s.setAttribute('nomodule', '');
  s.src = bp + src;
  document.body.appendChild(s);
}
    `;
  }
}

export default function buildRewrite() {
  return {
    name: 'build-rewrite',
    writeBundle() {
      const processor = new ElementProcessor();
      return processor.processBundle();
    }
  };
}
